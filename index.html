<!-- INÍCIO do módulo de Persistência local (IndexedDB) + Outbox + Sincronização -->
<script>
(function(){
  // ======= CONFIGURAÇÃO: coloque aqui o link do seu Apps Script =======
  const API_URL = 'https://script.google.com/macros/s/AKfycbxxfLapr6A4RKVppkk8FL_3ghAsN1DkdXkZxyakqY_ahCYb-1S_xYmISQDgBv4xmIWH/exec';
  // ==============================================================

  const DB_NAME = 'caixa_freitas_db';
  const DB_VERSION = 1;
  let idbDB = null;

  // ---------- IndexedDB helpers ----------
  function dbInit() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('state')) db.createObjectStore('state');
        if (!db.objectStoreNames.contains('outbox')) db.createObjectStore('outbox', { keyPath: 'id', autoIncrement: true });
      };
      req.onsuccess = (e) => { idbDB = e.target.result; resolve(); };
      req.onerror = (e) => reject(e.target.error);
    });
  }

  function dbPut(store, key, value) {
    return new Promise((resolve, reject) => {
      const tx = idbDB.transaction([store], 'readwrite');
      const s = tx.objectStore(store);
      const r = s.put(value, key);
      r.onsuccess = () => resolve();
      r.onerror = (ev) => reject(ev.target.error);
    });
  }

  function dbGet(store, key) {
    return new Promise((resolve, reject) => {
      const tx = idbDB.transaction([store], 'readonly');
      const s = tx.objectStore(store);
      const r = s.get(key);
      r.onsuccess = () => resolve(r.result);
      r.onerror = (ev) => reject(ev.target.error);
    });
  }

  function dbAddOutbox(item) {
    return new Promise((resolve, reject) => {
      const tx = idbDB.transaction(['outbox'], 'readwrite');
      const s = tx.objectStore('outbox');
      const r = s.add(item);
      r.onsuccess = () => resolve(r.result);
      r.onerror = (ev) => reject(ev.target.error);
    });
  }

  function dbGetAllOutbox() {
    return new Promise((resolve, reject) => {
      const tx = idbDB.transaction(['outbox'], 'readonly');
      const s = tx.objectStore('outbox');
      const r = s.getAll();
      r.onsuccess = () => resolve(r.result || []);
      r.onerror = (ev) => reject(ev.target.error);
    });
  }

  function dbDeleteOutbox(id) {
    return new Promise((resolve, reject) => {
      const tx = idbDB.transaction(['outbox'], 'readwrite');
      const s = tx.objectStore('outbox');
      const r = s.delete(id);
      r.onsuccess = () => resolve();
      r.onerror = (ev) => reject(ev.target.error);
    });
  }

  // ---------- Estado local (save / load) ----------
  async function saveAppState() {
    if (!idbDB) return;
    try {
      const state = {
        cart: (window.cart !== undefined) ? window.cart : null,
        total: (window.total !== undefined) ? window.total : null,
        paymentMethod: (window.paymentMethod !== undefined) ? window.paymentMethod : null,
        turnsData: (window.turnsData !== undefined) ? window.turnsData : null,
        currentTurn: (window.currentTurn !== undefined) ? window.currentTurn : null,
        receivedAmount: (window.receivedAmount !== undefined) ? window.receivedAmount : null,
        savedAt: new Date().toISOString()
      };
      await dbPut('state', 'appState', state);
      // console.log('[persist] state saved');
    } catch (e) {
      console.warn('[persist] saveAppState error', e);
    }
  }

  async function loadAppState() {
    if (!idbDB) return null;
    try {
      const state = await dbGet('state', 'appState');
      if (!state) return null;
      if (state.cart !== undefined) window.cart = state.cart || [];
      if (state.total !== undefined) window.total = state.total || 0;
      if (state.paymentMethod !== undefined) window.paymentMethod = state.paymentMethod || '';
      if (state.turnsData !== undefined) window.turnsData = state.turnsData || {};
      if (state.currentTurn !== undefined) window.currentTurn = state.currentTurn || null;
      if (state.receivedAmount !== undefined) window.receivedAmount = state.receivedAmount || 0;
      if (typeof window.updateCart === 'function') {
        try { window.updateCart(); } catch(e){}
      }
      return state;
    } catch (e) {
      console.warn('[persist] loadAppState error', e);
      return null;
    }
  }

  // ---------- Outbox / Sync ----------
  async function enqueueSync(item) {
    if (!idbDB) return;
    try {
      item.createdAt = new Date().toISOString();
      item.synced = false;
      await dbAddOutbox(item);
      trySync(); // tenta sincronizar logo em seguida
    } catch (e) {
      console.warn('[outbox] enqueue error', e);
    }
  }

  let syncRunning = false;
  async function trySync() {
    if (!navigator.onLine) return;
    if (!idbDB) return;
    if (syncRunning) return;
    syncRunning = true;
    try {
      const out = await dbGetAllOutbox();
      for (const item of out) {
        try {
          const resp = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(item)
          });
          if (resp.ok) {
            await dbDeleteOutbox(item.id);
            console.log('[sync] item sent id=', item.id);
          } else {
            console.warn('[sync] server returned', resp.status);
            break; // pare para evitar loop rápido
          }
        } catch (err) {
          console.warn('[sync] network error', err);
          break;
        }
      }
    } finally {
      syncRunning = false;
    }
  }

  // tenta sincronizar quando voltar online e a cada minuto
  window.addEventListener('online', () => { trySync(); });
  setInterval(() => { trySync(); }, 60 * 1000);

  // ---------- Inicialização segura ----------
  async function initAppPersistence() {
    try {
      await dbInit();
      await loadAppState();
      // tenta restaurar UI do turno sem forçar execução perigosa
      try {
        if (window.currentTurn && document.getElementById('turnSelection') && document.getElementById('mainApp')) {
          const turnSelection = document.getElementById('turnSelection');
          const mainApp = document.getElementById('mainApp');
          if (turnSelection && mainApp) {
            try { turnSelection.style.display = 'none'; } catch(e) {}
            try { mainApp.classList.add('show'); } catch(e) {}
            if (document.getElementById('turnText')) {
              try { document.getElementById('turnText').textContent = (window.currentTurn.name || 'Turno') + ' - ' + (window.currentTurn.startTime || ''); } catch(e){}
            }
          }
        }
      } catch(e){}
      trySync();
    } catch (err) {
      console.warn('[persist] init error', err);
    }
  }

  document.addEventListener('DOMContentLoaded', initAppPersistence);

  // ---------- Integração automática nas funções existentes ----------
  // (wrapFunction tenta interceptar chamadas às funções do seu app e salvar/sincronizar após execução)
  function wrapFunction(name, afterFn) {
    try {
      const original = window[name];
      if (typeof original !== 'function') return;
      window[name] = function(...args) {
        let res;
        try {
          res = original.apply(this, args);
        } catch (e) {
          console.error('[wrap] error running original', name, e);
          throw e;
        }
        try {
          afterFn.apply(this, args);
        } catch (e) {
          console.warn('[wrap] afterFn error for', name, e);
        }
        return res;
      };
    } catch (e) {
      console.warn('wrapFunction failed for', name, e);
    }
  }

  const saveAfter = () => { saveAppState().catch(()=>{}); };

  // Ao criar uma venda (nome comum: processNext)
  wrapFunction('processNext', function(){ 
    try {
      if (window.lastCreatedSale) {
        enqueueSync({ type: 'sale', payload: window.lastCreatedSale }).catch(()=>{});
      }
    } catch(e){}
    saveAfter();
  });

  // Ao submeter pagamento
  wrapFunction('submitPayment', function(){
    try {
      if (window.lastCreatedPayment) {
        enqueueSync({ type: 'payment', payload: window.lastCreatedPayment }).catch(()=>{});
      }
    } catch(e){}
    saveAfter();
  });

  // Ao submeter sangria/withdrawal
  wrapFunction('submitWithdrawal', function(){
    try {
      if (window.lastCreatedWithdrawal) {
        enqueueSync({ type: 'withdrawal', payload: window.lastCreatedWithdrawal }).catch(()=>{});
      }
    } catch(e){}
    saveAfter();
  });

  // Wraps gerais para cart/turns
  ['addProduct','removeItem','editItemQuantity','updateCart','startTurn'].forEach(fn=>{
    wrapFunction(fn, saveAfter);
  });

  // Substitui selectPayment por versão segura que persiste estado (se necessário)
  (function(){
    const orig = window.selectPayment;
    window.selectPayment = function(method, evt){
      try {
        if (typeof orig === 'function') {
          try { orig(method, evt); } catch(e){ console.warn('original selectPayment failed', e); }
        } else {
          window.paymentMethod = method;
          if (evt && evt.target) {
            try {
              const btn = evt.target.closest && evt.target.closest('.payment-btn') ? evt.target.closest('.payment-btn') : evt.target;
              if (btn) {
                document.querySelectorAll && document.querySelectorAll('.payment-btn').forEach(b=>b.classList && b.classList.remove('selected'));
                btn.classList && btn.classList.add('selected');
              }
            } catch(e){}
          }
        }
      } catch(e){}
      // persistir estado sem exibir notificação
      saveAppState().catch(()=>{});
    };
  })();

  // Export helpers to window for manual use (opcional)
  window.__caixa_persistence = {
    enqueueSync,
    trySync,
    saveAppState,
    loadAppState
  };

})(); // fim IIFE
</script>
<!-- FIM do módulo de Persistência -->
